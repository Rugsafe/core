syntax = "proto3";
package cosmwasm.will;

import "gogoproto/gogo.proto";
import "cosmos/base/v1beta1/coin.proto";

option go_package = "github.com/CosmWasm/wasmd/x/will/types";
option (gogoproto.goproto_getters_all) = false;
option (gogoproto.equal_all) = true;

// ExecutionComponent defines a single actionable component within a will.
message ExecutionComponent {
  // component_type enables the inclusion of different types of execution
  // component name
  string name = 1;
  // component id
  string id = 2;
  // components within a will.
  string status = 3;
  // component type
  oneof component_type {
    TransferComponent transfer = 4; // Represents an asset transfer action.
    ClaimComponent claim =
        5; // Represents a claim action that a beneficiary must perform.
    // ContractComponent contract = 3; // Future use: Represents an interaction
    // with a smart contract.
  }
}

// TransferComponent is used for direct asset transfers.
message TransferComponent {
  string to = 1; // Destination address for the asset transfer.
  cosmos.base.v1beta1.Coin amount =
      3; // The amount and type of asset to transfer.
}

// ClaimComponent is designed for actions requiring a claim with proof.
message ClaimComponent {
  // scheme_type allows for different cryptographic schemes for claims.
  oneof scheme_type {
    PedersenCommitment pedersen = 2; // Represents a Pedersen commitment scheme.
    SchnorrSignature schnorr = 3;    // Represents a Schnorr signature scheme.
    GnarkZkSnark gnark = 4; // Represents a zk-SNARK scheme using Gnark.
  }
}

// SchnorrSignature is used for claims that require a Schnorr signature.
message SchnorrSignature {
  bytes public_key = 1; // The public key associated with the signature.
  bytes signature = 2;  // The digital signature for claim verification.
  string message = 3;   // An optional message that may accompany the signature.
}

// PedersenCommitment enables the use of a Pedersen commitment for claims.
message PedersenCommitment {
  bytes commitment = 1; // The commitment hash, representing the hidden value.
  bytes random_factor = 2; // The random factor used to generate the commitment,
                           // enhancing privacy.
  bytes value = 3; // The actual value being committed, revealed during claim.
  bytes blinding_factor =
      4; // The blinding factor used alongside the value for claim verification.
}

// GnarkZkSnark is for claims using zero-knowledge succinct non-interactive
// arguments of knowledge.
message GnarkZkSnark {
  bytes verification_key =
      1;                   // The public key for verifying the zk-SNARK proof.
  bytes public_inputs = 2; // Public inputs required for the proof verification.
  bytes proof = 3; // The zk-SNARK proof demonstrating knowledge of a secret
                   // without revealing it.
}

// Will represents the entire structure of a will.
message Will {
  option (gogoproto.equal) = true;
  string id = 1
      [ (gogoproto.customname) = "ID" ]; // Unique identifier for the will.
  string creator = 2 [ (gogoproto.customname) = "Creator" ]; // will creator
  string name = 3
      [ (gogoproto.customname) = "Name" ]; // User-generated name for the will.
  string beneficiary = 4 [
    (gogoproto.customname) = "Beneficiary"
  ]; // The designated beneficiary or receiver of the will's assets.
  int64 height = 5 [ (gogoproto.customname) =
                         "Height" ]; // The designated block to trigger the will
  string status = 6
      [ (gogoproto.customname) =
            "Status" ]; // The designated block to trigger the will
  repeated ExecutionComponent components = 7 [
    (gogoproto.customname) = "Components"
  ]; // The list of execution components that make up the will.
}

// type to hold wills
message Wills {
  // the set of wills to return
  repeated Will wills = 1 [ (gogoproto.customname) = "Wills" ];
}

// WillIds represents a list of will IDs.
message WillIds { repeated string ids = 1; }